set dotenv-load := true
set dotenv-required := true
set quiet := true

jenkins_url := '${JENKINS_PROTOCOL}://${JENKINS_HOST}:${JENKINS_PORT}'
sudo := if env('SUDO') == '1' { 'sudo ' } else { '' }

alias j := jcli
alias dl := download
alias s := send-local-config
alias r := reload-config
alias v := view-config
alias a := apply-config

# Initialize Jenkins
[group("Init")]
init-jenkins:
    just start
    just instructions

# Instructions after initializing Jenkins
[group("Init")]
instructions:
    #!/usr/bin/bash
    s=""
    s+="1. Go to {{ YELLOW }}{{ jenkins_url }}/user/$(just secret jenkins_username)/security{{ NORMAL }} (login if prompted)"
    s+="\n2. Create your API token"
    s+="\n3. Copy the token and set {{ RED + BOLD }}JENKINS_API_TOKEN{{ NORMAL }} in your {{ YELLOW }}.env{{ NORMAL }} file"
    s+="\n4. Run {{ GREEN }}just dl{{ NORMAL }} to download the Jenkins CLI"
    s+="\n\nJenkins and your local environment should now be fully setup."
    s+="\n\nIf you make changes to the configuration via the Jenkins UI and want to save"
    s+="\nthose changes, you can view the current configuration used by Jenkins using"
    s+="\n{{ GREEN }}just v{{ NORMAL }}, copy the modified parts, and update the {{ YELLOW }}configs/*.yml{{ NORMAL }} files."
    s+="\n\n{{ BG_BLUE }} NOTE {{ NORMAL }}"
    s+="\nJob configurations are not obtainable in Job DSL API syntax and need to"
    s+="\nbe manually written in {{ YELLOW }}configs/dynamic.yml{{ NORMAL }}."
    s+="\n\nIf you want to see this text again use {{ GREEN }}just instructions{{ NORMAL }}"
    printf "$s\n"

# Check if Jenkins is ready
[group("Init")]
check:
    count=$({{ sudo }}docker compose -p ${COMPOSE_PROJECT_NAME} logs | grep -i -c "Jenkins is fully up and running"); \
    if [ $count -gt 0 ]; then \
        echo "Jenkins is ready"; \
    else \
        echo "Jenkins is not ready"; \
    fi

# Create initial files
[group("Init")]
init-files:
    file="./secrets/secrets.properties"; if [ ! -f "$file" ]; then cp ${file}.example $file; echo "Created $file"; fi
    file="./secrets/github_app_team_key.pem"; if [ ! -f "$file" ]; then touch $file; echo "Created $file"; fi
    file="./secrets/kubeconfig.yml"; if [ ! -f "$file" ]; then touch $file; echo "Created $file"; fi
    file="./ssh/config"; if [ ! -f "$file" ]; then cp ${file}.example $file; echo "Created $file"; fi

# Start Jenkins
[group("Docker")]
start:
    {{ sudo }}docker compose -p ${COMPOSE_PROJECT_NAME} up --wait --build

# Stop Jenkins
[group("Docker")]
stop:
    {{ sudo }}docker compose -p ${COMPOSE_PROJECT_NAME} down

# Destroy all of Jenkins, including the volumes
[group("Docker")]
destroy:
    {{ sudo }}docker compose -p ${COMPOSE_PROJECT_NAME} down -v --rmi all

# View commands for the Jenkins server
[group("Jenkins CLI")]
help:
    just j help
    echo "You can also go to {{ YELLOW }}{{ jenkins_url }}/cli{{ NORMAL }} to view commands."

# View help information for the Jenkins CLI
[group("Jenkins CLI")]
help-cli:
    java -jar $JENKINS_CLI

# Downloads the Jenkins CLI locally
[group("Init")]
download:
    curl {{ jenkins_url }}/jnlpJars/jenkins-cli.jar --output $JENKINS_CLI

# Shorthand to use the Jenkins CLI
[group("Jenkins CLI")]
jcli *args:
    java -jar $JENKINS_CLI -s {{ jenkins_url }} -auth $(just secret jenkins_username):$JENKINS_API_TOKEN {{ args }}

# Copies the JCasC configurations to the Jenkins container
[group("Jenkins CLI")]
send-local-config:
    {{ sudo }}docker cp configs/. ${COMPOSE_PROJECT_NAME}-jenkins-1:/var/jenkins_home/casc_configs/

# Reloads the JCasC configuration on the Jenkins container
[group("Jenkins CLI")]
reload-config:
    just j reload-jcasc-configuration
    echo "JCasC config reloaded"

# Displays the current JCasC configuration used by Jenkins
[group("Jenkins CLI")]
view-config:
    just j export-configuration

# Sends the dynamic config file to the Jenkins server and reloads the configuration
[group("Jenkins CLI")]
apply-config:
    just j apply-configuration < ./configs/dynamic.yml

# https://plugins.jenkins.io/github/#plugin-content-manual-mode
# https://stackoverflow.com/a/51545557

# Tunneling using localtunnel. Only for local development
[group("Extra")]
tunnel:
    echo "Port: {{ GREEN }}$JENKINS_PORT{{ NORMAL }}"
    npx localtunnel -p $JENKINS_PORT -s "$TUNNEL_SUBDOMAIN" --print-requests

# Tunnel password
[group("Extra")]
tunnel-pw:
    curl https://loca.lt/mytunnelpassword

# Obtain the value for a given secret property
[group("Util")]
secret prop:
    grep "^{{ prop }}=" ./secrets/secrets.properties | cut -d "=" -f 2-

# https://github.com/jenkinsci/github-branch-source-plugin/blob/master/docs/github-app.adoc#creating-the-github-app

# Convert GitHub keys to a compatible Jenkins format
[group("Util")]
convert-key in out:
    openssl pkcs8 -topk8 -inform PEM -outform PEM -in {{ in }} -out {{ out }} -nocrypt

# Displays useful Jenkins URLs. Use ip=1 to show all URLs with an IP
[group("Extra")]
urls ip="0":
    #!/usr/bin/bash
    url="{{ jenkins_url }}"
    address=$(just ip)

    if [ "{{ ip }}" == "ip=1" ]; then
        url="${JENKINS_PROTOCOL}://${address}:${JENKINS_PORT}"
    fi

    width=30
    s=""
    s+=$(printf "%-${width}s %s" "{{ YELLOW }}Job DSL API{{ NORMAL }}" "${url}/plugin/job-dsl/api-viewer/index.html")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}User Security{{ NORMAL }}" "${url}/user/$(just secret jenkins_username)/security")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Blue Ocean{{ NORMAL }}" "${url}/blue/pipelines")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}CLI Page{{ NORMAL }}" "${url}/cli")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Pipeline Syntax{{ NORMAL }}" "${url}/pipeline-syntax")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Local URL{{ NORMAL }}" "${url}")
    s+=$(printf "\n%-${width}s %s" "{{ YELLOW }}Public URL{{ NORMAL }}" "${JENKINS_PROTOCOL}://${address}:${JENKINS_PORT}")
    printf "$s\n"

# Get your current public ip
[group("Extra")]
ip:
    curl -s ifconfig.me

# Watch logs
[group("Extra")]
logs:
    {{ sudo }}docker compose -p ${COMPOSE_PROJECT_NAME} logs -f -t

# Sort plugins.txt
[group("Util")]
plugins:
    cat plugins.txt | sort | tee plugins.txt

# Update the files in the current directory with gitsnip (for prod environment)
[group("Util")]
update-files branch="main":
    gitsnip $GITSNIP_REPO $GITSNIP_FOLDER . -b {{ branch }}

# Clean up docker
[group("Util")]
cdocker:
    {{ sudo }}docker builder prune -af
    {{ sudo }}docker container prune -f
    {{ sudo }}docker volume prune -f
    {{ sudo }}docker image prune -af

# Generate an ssh key for docker builders
[group("Util")]
gen-docker-ssh-key:
    ssh-keygen -t ed25519 -a 100 -f ssh/docker-ssh-key -C "docker-ssh-key" -N ""

# Add all hosts in the ./ssh/config file to known hosts
[group("Init")]
add-all-known-hosts:
    #!/usr/bin/bash

    config_file="./ssh/config"

    if [ ! -f "$config_file" ]; then
        echo "{{ BG_RED }} WARNING {{ NORMAL }} No config file found: $config_file"
        exit 0
    fi

    rm -rf ./ssh/known_hosts
    touch ./ssh/known_hosts
    hosts=$(just _get-all-hosts)

    for host in "${hosts[@]}"; do
        hostname=$(just _get-hostname $host)
        port=$(just _get-port $host)
        just _add-known-host $hostname $port
    done

_get-all-hosts:
    grep -E '^Host ' ./ssh/config | awk '{print $2}'

_get-port host:
    ssh -G {{ host }} -F ./ssh/config | awk '/^port / {print $2}'

_get-hostname host:
    ssh -G {{ host }} -F ./ssh/config | awk '/^hostname / {print $2}'

_add-known-host hostname port:
    ssh-keyscan -H -p {{ port }} {{ hostname }} >> ./ssh/known_hosts
